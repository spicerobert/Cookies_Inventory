# 餅乾庫存計算邏輯說明

## 計算公式

對每一天、每一種餅乾：

```
期末庫存 = 期初庫存 + 當天預計入庫數量 - 當天組裝需求量
```

**當天的期末庫存 = 隔天的期初庫存**

## 計算流程（類似SQL Cursor的逐筆計算）

### 初始化
- 期初庫存（第1天）= 從Google Sheets讀取的「庫存狀態」+「在製品庫存」

### 逐日計算（for循環，類似Cursor）

對每一天（day_offset = 0 到 13，共14天）：
  對每一種餅乾：
    1. 期初庫存 = 前一天的期末庫存（如果是第1天，則是初始庫存）
    2. 當天預計入庫數量 = 從生產排程查詢（完工入庫日期 = 當天）
    3. 當天組裝需求量 = 從組裝排程查詢（組裝日期 = 當天）
    4. 期末庫存 = 期初庫存 + 當天預計入庫 - 當天組裝需求
    5. 更新：當天的期末庫存 → 作為下一天的期初庫存

## 程式碼邏輯（Python實現）

```python
# 初始化：今天的期初庫存
current_inventory = initial_inventory.copy()  # 從Google Sheets讀取的庫存

# 逐日計算
for day_offset in range(14):  # 未來14天
    date = today + timedelta(days=day_offset)
    
    for cookie_code in all_cookies:  # 每一種餅乾
        # 1. 期初庫存 = 前一天的期末庫存
        beginning_qty = current_inventory.get(cookie_code, 0.0)
        
        # 2. 當天預計入庫數量 = 從生產排程查詢（完工入庫日期 = 當天）
        completion_qty = production_schedule.get(date, {}).get(cookie_code, 0.0)
        
        # 3. 當天組裝需求量 = 從組裝排程查詢（組裝日期 = 當天）
        demand_qty = assembly_schedule.get(date, {}).get(cookie_code, 0.0)
        
        # 4. 期末庫存 = 期初 + 入庫 - 組裝需求
        ending_qty = beginning_qty + completion_qty - demand_qty
        
        # 5. 更新：當天的期末庫存 → 作為下一天的期初庫存
        current_inventory[cookie_code] = ending_qty
```

## 輸出欄位順序

目前的欄位順序：
1. 日期
2. 餅乾代號
3. 期初庫存
4. 預計完工入庫 ← 當天入庫數量
5. 組裝需求量 ← 當天組裝需求
6. 期末庫存
7. 是否負庫存
8. 缺口數量

**建議調整為：**
1. 日期
2. 餅乾代號
3. 期初庫存
4. 當天組裝需求 ← 調整順序
5. 當天入庫數量 ← 調整順序
6. 期末庫存
7. 是否負庫存
8. 缺口數量
